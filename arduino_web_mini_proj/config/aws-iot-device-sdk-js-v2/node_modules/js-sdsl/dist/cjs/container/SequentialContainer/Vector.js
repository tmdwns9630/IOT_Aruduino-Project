"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VectorIterator = void 0;
const index_1 = require("../ContainerBase/index");
const checkParams_1 = require("../../utils/checkParams");
const index_2 = __importDefault(require("./Base/index"));
class VectorIterator extends index_1.ContainerIterator {
    constructor(index, size, getElementByPos, setElementByPos, iteratorType = 'normal') {
        super(iteratorType);
        this.node = index;
        this.size = size;
        this.getElementByPos = getElementByPos;
        this.setElementByPos = setElementByPos;
    }
    get pointer() {
        (0, checkParams_1.checkWithinAccessParams)(this.node, 0, this.size() - 1);
        return this.getElementByPos(this.node);
    }
    set pointer(newValue) {
        (0, checkParams_1.checkWithinAccessParams)(this.node, 0, this.size() - 1);
        this.setElementByPos(this.node, newValue);
    }
    pre() {
        if (this.iteratorType === 'reverse') {
            if (this.node === this.size() - 1) {
                throw new RangeError('Vector iterator access denied!');
            }
            this.node += 1;
        }
        else {
            if (this.node === 0) {
                throw new RangeError('Vector iterator access denied!');
            }
            this.node -= 1;
        }
        return this;
    }
    next() {
        if (this.iteratorType === 'reverse') {
            if (this.node === -1) {
                throw new RangeError('Vector iterator access denied!');
            }
            this.node -= 1;
        }
        else {
            if (this.node === this.size()) {
                throw new RangeError('Vector Iterator access denied!');
            }
            this.node += 1;
        }
        return this;
    }
    equals(obj) {
        if (obj.constructor.name !== this.constructor.name) {
            throw new TypeError(`Obj's constructor is not ${this.constructor.name}!`);
        }
        if (this.iteratorType !== obj.iteratorType) {
            throw new TypeError('Iterator type error!');
        }
        return this.node === obj.node;
    }
}
exports.VectorIterator = VectorIterator;
class Vector extends index_2.default {
    constructor(container = [], copy = true) {
        super();
        if (Array.isArray(container)) {
            this.vector = copy ? [...container] : container;
            this.length = container.length;
        }
        else {
            this.vector = [];
            container.forEach(element => this.pushBack(element));
        }
        this.size = this.size.bind(this);
        this.getElementByPos = this.getElementByPos.bind(this);
        this.setElementByPos = this.setElementByPos.bind(this);
    }
    clear() {
        this.length = 0;
        this.vector.length = 0;
    }
    begin() {
        return new VectorIterator(0, this.size, this.getElementByPos, this.setElementByPos);
    }
    end() {
        return new VectorIterator(this.length, this.size, this.getElementByPos, this.setElementByPos);
    }
    rBegin() {
        return new VectorIterator(this.length - 1, this.size, this.getElementByPos, this.setElementByPos, 'reverse');
    }
    rEnd() {
        return new VectorIterator(-1, this.size, this.getElementByPos, this.setElementByPos, 'reverse');
    }
    front() {
        return this.vector[0];
    }
    back() {
        return this.vector[this.length - 1];
    }
    forEach(callback) {
        for (let i = 0; i < this.length; ++i) {
            callback(this.vector[i], i);
        }
    }
    getElementByPos(pos) {
        (0, checkParams_1.checkWithinAccessParams)(pos, 0, this.length - 1);
        return this.vector[pos];
    }
    eraseElementByPos(pos) {
        (0, checkParams_1.checkWithinAccessParams)(pos, 0, this.length - 1);
        this.vector.splice(pos, 1);
        this.length -= 1;
    }
    eraseElementByValue(value) {
        let index = 0;
        for (let i = 0; i < this.length; ++i) {
            if (this.vector[i] !== value) {
                this.vector[index++] = this.vector[i];
            }
        }
        this.length = this.vector.length = index;
    }
    eraseElementByIterator(iter) {
        // @ts-ignore
        const node = iter.node;
        iter = iter.next();
        this.eraseElementByPos(node);
        return iter;
    }
    pushBack(element) {
        this.vector.push(element);
        this.length += 1;
    }
    popBack() {
        if (!this.length)
            return;
        this.vector.pop();
        this.length -= 1;
    }
    setElementByPos(pos, element) {
        (0, checkParams_1.checkWithinAccessParams)(pos, 0, this.length - 1);
        this.vector[pos] = element;
    }
    insert(pos, element, num = 1) {
        (0, checkParams_1.checkWithinAccessParams)(pos, 0, this.length);
        this.vector.splice(pos, 0, ...new Array(num).fill(element));
        this.length += num;
    }
    find(element) {
        for (let i = 0; i < this.length; ++i) {
            if (this.vector[i] === element) {
                return new VectorIterator(i, this.size, this.getElementByPos, this.getElementByPos);
            }
        }
        return this.end();
    }
    reverse() {
        this.vector.reverse();
    }
    unique() {
        let index = 1;
        for (let i = 1; i < this.length; ++i) {
            if (this.vector[i] !== this.vector[i - 1]) {
                this.vector[index++] = this.vector[i];
            }
        }
        this.length = this.vector.length = index;
    }
    sort(cmp) {
        this.vector.sort(cmp);
    }
    [Symbol.iterator]() {
        return function* () {
            return yield* this.vector;
        }.bind(this)();
    }
}
exports.default = Vector;
