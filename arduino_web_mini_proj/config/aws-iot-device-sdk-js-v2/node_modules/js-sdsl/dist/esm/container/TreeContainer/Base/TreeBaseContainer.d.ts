import { Container } from "../../ContainerBase/index";
import TreeIterator from './TreeIterator';
import TreeNode from './TreeNode';
declare abstract class TreeBaseContainer<K, V> extends Container<K | [K, V]> {
    protected root: TreeNode<K, V> | undefined;
    protected header: TreeNode<K, V>;
    protected cmp: (x: K, y: K) => number;
    protected constructor(cmp?: (x: K, y: K) => number);
    protected _lowerBound(curNode: TreeNode<K, V> | undefined, key: K): TreeNode<K, V>;
    protected _upperBound(curNode: TreeNode<K, V> | undefined, key: K): TreeNode<K, V>;
    protected _reverseLowerBound(curNode: TreeNode<K, V> | undefined, key: K): TreeNode<K, V>;
    protected _reverseUpperBound(curNode: TreeNode<K, V> | undefined, key: K): TreeNode<K, V>;
    protected eraseNodeSelfBalance(curNode: TreeNode<K, V>): void;
    protected eraseNode(curNode: TreeNode<K, V>): TreeNode<K, V> | undefined;
    protected inOrderTraversal: (curNode: TreeNode<K, V> | undefined, callback: (curNode: TreeNode<K, V>) => boolean) => boolean;
    protected insertNodeSelfBalance(curNode: TreeNode<K, V>): void;
    protected findElementNode(curNode: TreeNode<K, V> | undefined, key: K): TreeNode<K, V> | undefined;
    protected set(key: K, value?: V): void;
    clear(): void;
    eraseElementByPos(pos: number): void;
    /**
     * Removes the elements of the specified key.
     */
    eraseElementByKey(key: K): void;
    /**
     * @return An iterator point to the next iterator.
     * Removes element by iterator.
     */
    eraseElementByIterator(iter: TreeIterator<K, V>): TreeIterator<K, V>;
    /**
     * @return The height of the RB-tree.
     */
    getHeight(): number;
}
export default TreeBaseContainer;
