"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vector_1 = __importDefault(require("../SequentialContainer/Vector"));
const OrderedMap_1 = __importDefault(require("../TreeContainer/OrderedMap"));
const index_1 = __importDefault(require("./Base/index"));
class HashMap extends index_1.default {
    constructor(container = [], initBucketNum, hashFunc) {
        super(initBucketNum, hashFunc);
        this.hashTable = [];
        container.forEach(element => this.setElement(element[0], element[1]));
    }
    reAllocate() {
        if (this.bucketNum >= index_1.default.maxBucketNum)
            return;
        const newHashTable = [];
        const originalBucketNum = this.bucketNum;
        this.bucketNum <<= 1;
        for (let index = 0; index < originalBucketNum; ++index) {
            const container = this.hashTable[index];
            if (!container || container.empty())
                continue;
            if (container.size() === 1) {
                const element = container.front();
                newHashTable[this.hashFunc(element[0]) & (this.bucketNum - 1)] = new Vector_1.default([element], false);
                continue;
            }
            const lowList = [];
            const highList = [];
            container.forEach(pair => {
                const hashCode = this.hashFunc(pair[0]);
                if ((hashCode & originalBucketNum) === 0) {
                    lowList.push(pair);
                }
                else
                    highList.push(pair);
            });
            if (container instanceof OrderedMap_1.default) {
                if (lowList.length > HashMap.untreeifyThreshold) {
                    newHashTable[index] = new OrderedMap_1.default(lowList);
                }
                else if (lowList.length) {
                    newHashTable[index] = new Vector_1.default(lowList, false);
                }
                if (highList.length > HashMap.untreeifyThreshold) {
                    newHashTable[index + originalBucketNum] = new OrderedMap_1.default(highList);
                }
                else if (highList.length) {
                    newHashTable[index + originalBucketNum] = new Vector_1.default(highList, false);
                }
            }
            else {
                if (lowList.length >= HashMap.treeifyThreshold) {
                    newHashTable[index] = new OrderedMap_1.default(lowList);
                }
                else if (lowList.length) {
                    newHashTable[index] = new Vector_1.default(lowList, false);
                }
                if (highList.length >= HashMap.treeifyThreshold) {
                    newHashTable[index + originalBucketNum] = new OrderedMap_1.default(highList);
                }
                else if (highList.length) {
                    newHashTable[index + originalBucketNum] = new Vector_1.default(highList, false);
                }
            }
        }
        this.hashTable = newHashTable;
    }
    clear() {
        this.length = 0;
        this.bucketNum = this.initBucketNum;
        this.hashTable = [];
    }
    forEach(callback) {
        let index = 0;
        for (let i = 0; i < this.bucketNum; ++i) {
            if (!this.hashTable[i])
                continue;
            this.hashTable[i].forEach(element => callback(element, index++));
        }
    }
    /**
     * Insert a new key-value pair or set value by key.
     */
    setElement(key, value) {
        const index = this.hashFunc(key) & (this.bucketNum - 1);
        if (!this.hashTable[index]) {
            this.length += 1;
            this.hashTable[index] = new Vector_1.default([[key, value]], false);
        }
        else {
            const preSize = this.hashTable[index].size();
            if (this.hashTable[index] instanceof Vector_1.default) {
                for (const pair of this.hashTable[index]) {
                    if (pair[0] === key) {
                        pair[1] = value;
                        return;
                    }
                }
                this.hashTable[index].pushBack([key, value]);
                if (this.hashTable[index].size() >= HashMap.treeifyThreshold) {
                    if (this.bucketNum <= HashMap.minTreeifySize) {
                        this.length += 1;
                        this.reAllocate();
                        return;
                    }
                    this.hashTable[index] = new OrderedMap_1.default(this.hashTable[index]);
                }
            }
            else
                this.hashTable[index].setElement(key, value);
            const curSize = this.hashTable[index].size();
            this.length += curSize - preSize;
        }
        if (this.length > this.bucketNum * HashMap.sigma) {
            this.reAllocate();
        }
    }
    /**
     * Gets the value of the element which has the specified key.
     */
    getElementByKey(key) {
        const index = this.hashFunc(key) & (this.bucketNum - 1);
        if (!this.hashTable[index])
            return undefined;
        if (this.hashTable[index] instanceof OrderedMap_1.default) {
            return this.hashTable[index].getElementByKey(key);
        }
        else {
            for (const pair of this.hashTable[index]) {
                if (pair[0] === key)
                    return pair[1];
            }
            return undefined;
        }
    }
    /**
     * Removes the element of the specified key.
     */
    eraseElementByKey(key) {
        const index = this.hashFunc(key) & (this.bucketNum - 1);
        if (!this.hashTable[index])
            return;
        const preSize = this.hashTable[index].size();
        if (this.hashTable[index] instanceof OrderedMap_1.default) {
            this.hashTable[index].eraseElementByKey(key);
            if (this.hashTable[index].size() <= HashMap.untreeifyThreshold) {
                this.hashTable[index] = new Vector_1.default(this.hashTable[index]);
            }
        }
        else {
            let pos = 0;
            for (const pair of this.hashTable[index]) {
                if (pair[0] === key) {
                    this.hashTable[index].eraseElementByPos(pos);
                    break;
                }
                pos += 1;
            }
        }
        const curSize = this.hashTable[index].size();
        this.length += curSize - preSize;
    }
    /**
     * @return If the specified element in the HashSet.
     */
    find(key) {
        const index = this.hashFunc(key) & (this.bucketNum - 1);
        if (!this.hashTable[index])
            return false;
        if (this.hashTable[index] instanceof OrderedMap_1.default) {
            return !this.hashTable[index].find(key)
                .equals(this.hashTable[index].end());
        }
        for (const pair of this.hashTable[index]) {
            if (pair[0] === key)
                return true;
        }
        return false;
    }
    /**
     * Using for 'for...of' syntax like Array.
     */
    [Symbol.iterator]() {
        return function* () {
            let index = 0;
            while (index < this.bucketNum) {
                while (index < this.bucketNum && !this.hashTable[index])
                    index += 1;
                if (index >= this.bucketNum)
                    break;
                for (const pair of this.hashTable[index])
                    yield pair;
                index += 1;
            }
        }.bind(this)();
    }
}
exports.default = HashMap;
