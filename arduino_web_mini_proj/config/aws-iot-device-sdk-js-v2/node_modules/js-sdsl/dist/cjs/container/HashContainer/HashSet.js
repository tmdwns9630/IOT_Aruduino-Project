"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const OrderedSet_1 = __importDefault(require("../TreeContainer/OrderedSet"));
const index_1 = __importDefault(require("./Base/index"));
const Vector_1 = __importDefault(require("../SequentialContainer/Vector"));
class HashSet extends index_1.default {
    constructor(container = [], initBucketNum, hashFunc) {
        super(initBucketNum, hashFunc);
        this.hashTable = [];
        container.forEach(element => this.insert(element));
    }
    reAllocate() {
        if (this.bucketNum >= HashSet.maxBucketNum)
            return;
        const newHashTable = [];
        const originalBucketNum = this.bucketNum;
        this.bucketNum <<= 1;
        for (let index = 0; index < originalBucketNum; ++index) {
            const container = this.hashTable[index];
            if (!container || container.empty())
                continue;
            if (container.size() === 1) {
                const element = container.front();
                newHashTable[this.hashFunc(element) & (this.bucketNum - 1)] = new Vector_1.default([element], false);
                continue;
            }
            const lowList = [];
            const highList = [];
            container.forEach(element => {
                const hashCode = this.hashFunc(element);
                if ((hashCode & originalBucketNum) === 0) {
                    lowList.push(element);
                }
                else
                    highList.push(element);
            });
            if (container instanceof OrderedSet_1.default) {
                if (lowList.length > HashSet.untreeifyThreshold) {
                    newHashTable[index] = new OrderedSet_1.default(lowList);
                }
                else if (lowList.length) {
                    newHashTable[index] = new Vector_1.default(lowList, false);
                }
                if (highList.length > HashSet.untreeifyThreshold) {
                    newHashTable[index + originalBucketNum] = new OrderedSet_1.default(highList);
                }
                else if (highList.length) {
                    newHashTable[index + originalBucketNum] = new Vector_1.default(highList, false);
                }
            }
            else {
                if (lowList.length >= HashSet.treeifyThreshold) {
                    newHashTable[index] = new OrderedSet_1.default(lowList);
                }
                else if (lowList.length) {
                    newHashTable[index] = new Vector_1.default(lowList, false);
                }
                if (highList.length >= HashSet.treeifyThreshold) {
                    newHashTable[index + originalBucketNum] = new OrderedSet_1.default(highList);
                }
                else if (highList.length) {
                    newHashTable[index + originalBucketNum] = new Vector_1.default(highList, false);
                }
            }
        }
        this.hashTable = newHashTable;
    }
    clear() {
        this.length = 0;
        this.bucketNum = this.initBucketNum;
        this.hashTable = [];
    }
    forEach(callback) {
        let index = 0;
        for (let i = 0; i < this.bucketNum; ++i) {
            if (!this.hashTable[i])
                continue;
            this.hashTable[i].forEach(element => callback(element, index++));
        }
    }
    /**
     * Inserts element to Set.
     */
    insert(element) {
        const index = this.hashFunc(element) & (this.bucketNum - 1);
        if (!this.hashTable[index]) {
            this.hashTable[index] = new Vector_1.default([element], false);
            this.length += 1;
        }
        else {
            const preSize = this.hashTable[index].size();
            if (this.hashTable[index] instanceof Vector_1.default) {
                if (!this.hashTable[index].find(element)
                    .equals(this.hashTable[index].end()))
                    return;
                this.hashTable[index].pushBack(element);
                if (this.bucketNum <= HashSet.minTreeifySize) {
                    this.length += 1;
                    this.reAllocate();
                    return;
                }
                else if (this.hashTable[index].size() >= HashSet.treeifyThreshold) {
                    this.hashTable[index] = new OrderedSet_1.default(this.hashTable[index]);
                }
            }
            else
                this.hashTable[index].insert(element);
            const curSize = this.hashTable[index].size();
            this.length += curSize - preSize;
        }
        if (this.length > this.bucketNum * HashSet.sigma) {
            this.reAllocate();
        }
    }
    /**
     * Removes the elements of the specified value.
     */
    eraseElementByKey(element) {
        const index = this.hashFunc(element) & (this.bucketNum - 1);
        if (!this.hashTable[index])
            return;
        const preSize = this.hashTable[index].size();
        if (this.hashTable[index] instanceof Vector_1.default) {
            this.hashTable[index].eraseElementByValue(element);
        }
        else {
            this.hashTable[index].eraseElementByKey(element);
        }
        if (this.hashTable[index] instanceof OrderedSet_1.default) {
            if (this.hashTable[index].size() <= HashSet.untreeifyThreshold) {
                this.hashTable[index] = new Vector_1.default(this.hashTable[index]);
            }
        }
        const curSize = this.hashTable[index].size();
        this.length += curSize - preSize;
    }
    /**
     * @return If the specified element in the HashSet.
     */
    find(element) {
        const index = this.hashFunc(element) & (this.bucketNum - 1);
        if (!this.hashTable[index])
            return false;
        return !this.hashTable[index].find(element)
            .equals(this.hashTable[index].end());
    }
    /**
     * Using for 'for...of' syntax like Array.
     */
    [Symbol.iterator]() {
        return function* () {
            let index = 0;
            while (index < this.bucketNum) {
                while (index < this.bucketNum && !this.hashTable[index])
                    index += 1;
                if (index >= this.bucketNum)
                    break;
                for (const element of this.hashTable[index])
                    yield element;
                index += 1;
            }
        }.bind(this)();
    }
}
exports.default = HashSet;
