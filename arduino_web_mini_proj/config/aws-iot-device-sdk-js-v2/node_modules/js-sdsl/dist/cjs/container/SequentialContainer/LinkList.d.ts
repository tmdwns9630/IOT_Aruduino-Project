import { ContainerIterator, initContainer } from "../ContainerBase/index";
import SequentialContainer from './Base/index';
export declare class LinkNode<T> {
    value: T | undefined;
    pre: LinkNode<T> | undefined;
    next: LinkNode<T> | undefined;
    constructor(element?: T);
}
export declare class LinkListIterator<T> extends ContainerIterator<T> {
    private node;
    private readonly header;
    constructor(node: LinkNode<T>, header: LinkNode<T>, iteratorType?: 'normal' | 'reverse');
    get pointer(): T;
    set pointer(newValue: T);
    pre(): this;
    next(): this;
    equals(obj: LinkListIterator<T>): boolean;
}
declare class LinkList<T> extends SequentialContainer<T> {
    private header;
    private head;
    private tail;
    constructor(container?: initContainer<T>);
    clear(): void;
    begin(): LinkListIterator<T>;
    end(): LinkListIterator<T>;
    rBegin(): LinkListIterator<T>;
    rEnd(): LinkListIterator<T>;
    front(): T | undefined;
    back(): T | undefined;
    forEach(callback: (element: T, index: number) => void): void;
    getElementByPos(pos: number): T;
    eraseElementByPos(pos: number): void;
    eraseElementByValue(value: T): void;
    eraseElementByIterator(iter: LinkListIterator<T>): LinkListIterator<T>;
    pushBack(element: T): void;
    popBack(): void;
    setElementByPos(pos: number, element: T): void;
    insert(pos: number, element: T, num?: number): void;
    find(element: T): LinkListIterator<T>;
    reverse(): void;
    unique(): void;
    sort(cmp?: (x: T, y: T) => number): void;
    /**
     * Inserts an element to the beginning.
     */
    pushFront(element: T): void;
    /**
     * Removes the first element.
     */
    popFront(): void;
    /**
     * Merges two sorted lists.
     */
    merge(list: LinkList<T>): void;
    [Symbol.iterator](): Generator<T, void, unknown>;
}
export default LinkList;
