"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrderedMapIterator = void 0;
const checkParams_1 = require("../../utils/checkParams");
const TreeBaseContainer_1 = __importDefault(require("./Base/TreeBaseContainer"));
const TreeIterator_1 = __importDefault(require("./Base/TreeIterator"));
class OrderedMapIterator extends TreeIterator_1.default {
    constructor(node, header, iteratorType = 'normal') {
        super(node, header, iteratorType);
    }
    get pointer() {
        if (this.node === this.header) {
            throw new RangeError('OrderedMap iterator access denied');
        }
        return Object.defineProperties({}, {
            0: {
                get: () => {
                    return this.node.key;
                }
            },
            1: {
                get: () => {
                    return this.node.value;
                },
                set: (newValue) => {
                    this.node.value = newValue;
                }
            }
        });
    }
}
exports.OrderedMapIterator = OrderedMapIterator;
class OrderedMap extends TreeBaseContainer_1.default {
    constructor(container = [], cmp) {
        super(cmp);
        this.iterationFunc = function* (curNode) {
            if (curNode === undefined)
                return;
            yield* this.iterationFunc(curNode.left);
            yield [curNode.key, curNode.value];
            yield* this.iterationFunc(curNode.right);
        };
        this.iterationFunc = this.iterationFunc.bind(this);
        container.forEach(([key, value]) => this.setElement(key, value));
    }
    /**
     * @return Iterator pointing to the beginning element.
     */
    begin() {
        return new OrderedMapIterator(this.header.left || this.header, this.header);
    }
    /**
     * @return Iterator pointing to the super end like c++.
     */
    end() {
        return new OrderedMapIterator(this.header, this.header);
    }
    /**
     * @return Iterator pointing to the end element.
     */
    rBegin() {
        return new OrderedMapIterator(this.header.right || this.header, this.header, 'reverse');
    }
    /**
     * @return Iterator pointing to the super begin like c++.
     */
    rEnd() {
        return new OrderedMapIterator(this.header, this.header, 'reverse');
    }
    /**
     * @return The first element.
     */
    front() {
        if (!this.length)
            return undefined;
        const minNode = this.header.left;
        return [minNode.key, minNode.value];
    }
    /**
     * @return The last element.
     */
    back() {
        if (!this.length)
            return undefined;
        const maxNode = this.header.right;
        return [maxNode.key, maxNode.value];
    }
    /**
     * @param callback callback function, it's first param is an array which type is [key, value].
     */
    forEach(callback) {
        let index = 0;
        for (const pair of this)
            callback(pair, index++);
    }
    /**
     * @return An iterator to the first element not less than the given key.
     */
    lowerBound(key) {
        const resNode = this._lowerBound(this.root, key);
        return new OrderedMapIterator(resNode, this.header);
    }
    /**
     * @return An iterator to the first element greater than the given key.
     */
    upperBound(key) {
        const resNode = this._upperBound(this.root, key);
        return new OrderedMapIterator(resNode, this.header);
    }
    /**
     * @return An iterator to the first element not greater than the given key.
     */
    reverseLowerBound(key) {
        const resNode = this._reverseLowerBound(this.root, key);
        return new OrderedMapIterator(resNode, this.header);
    }
    /**
     * @return An iterator to the first element less than the given key.
     */
    reverseUpperBound(key) {
        const resNode = this._reverseUpperBound(this.root, key);
        return new OrderedMapIterator(resNode, this.header);
    }
    /**
     * Insert a new key-value pair or set value by key.
     */
    setElement(key, value) {
        this.set(key, value);
    }
    /**
     * @param key The key you want to find.
     * @return Iterator pointing to the element if found, or super end if not found.
     */
    find(key) {
        const curNode = this.findElementNode(this.root, key);
        if (curNode !== undefined) {
            return new OrderedMapIterator(curNode, this.header);
        }
        return this.end();
    }
    /**
     * Gets the value of the element of the specified key.
     */
    getElementByKey(key) {
        const curNode = this.findElementNode(this.root, key);
        return curNode ? curNode.value : undefined;
    }
    getElementByPos(pos) {
        (0, checkParams_1.checkWithinAccessParams)(pos, 0, this.length - 1);
        let res;
        let index = 0;
        for (const pair of this) {
            if (index === pos) {
                res = pair;
                break;
            }
            index += 1;
        }
        return res;
    }
    /**
     * Union the other Set to self.
     * waiting for optimization, this is O(mlog(n+m)) algorithm now, but we expect it to be O(mlog(n/m+1)).
     * More information => https://en.wikipedia.org/wiki/Red%E2%80%93black_tree#Set_operations_and_bulk_operations
     */
    union(other) {
        other.forEach(([key, value]) => this.setElement(key, value));
    }
    /**
     * Using for 'for...of' syntax like Array.
     */
    [Symbol.iterator]() {
        return this.iterationFunc(this.root);
    }
}
exports.default = OrderedMap;
